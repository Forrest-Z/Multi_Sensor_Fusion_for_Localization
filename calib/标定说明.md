# 相机内参标定
  ## 启动相机

  ```bash
  roslaunch bringup cam1.launch
  roslaunch bringup cam2.launch
  roslaunch bringup cam3.launch
  roslaunch bringup cam4.launch
  ```
  ## 标定

  ```bash
  rosrun camera_calibration cameracalibrator.py --size 11x8 --square 0.02 image:=/camera/color/image_raw camera:=/camera/color/image_raw --no-service-check
  ```
> --size是标定板内部角点的数量
> 
> --square参数是指小方格的尺寸(m)

点击calibrate之后会卡很久，等着sava变绿就好了，结果在/tmp文件夹


# 相机和雷达的外参标定
## 先把雷达和相机都启动
```bash
roslaunch bringup four_cam_bringup.launch
roslaunch bringip lidar.launch
```

## 测试aruco
```bash
roslaunch aruco_ros single.launch
```

## 配置conf文件夹参数文件
### config_file.txt
```
1.像素
2.x范围(按照相机坐标系，也就是横向)
3.y范围(纵向)
4.z范围(垂直于像素平面的方向)
5.激光强度阈值
6.marker数量
7.相机内参 (3x4)
10.迭代次数
11.雷达->相机 初始旋转角
12.雷达->相机 初始偏移量
```

### lidar_camera_calibration.yaml
```
camera topic
camera info topic
lidar topic
```

### marker_coordinates.txt
标定板的参数
```
1.标定板数量
2.s1
3.s2
4.b1
5.b2
6.e
7.下一个标定板参数
```

## 配置aruco_mapping的相机参数
把内参标定的txt文件结果复制到``.ini``文件中

## 启动标定
```bash
roslaunch lidar_camera_calibration find_transform.launch
```       
在Ubuntu18下面会报warning，Ubuntu16没出现

> GLib-GObject-CRITICAL **: 16:02:02.766: g_object_unref: assertion 'G_IS_OBJECT (object)' failed

目前出现相机框的时候，会触发阻塞函数等待键盘按键，不用管报错，**键盘按一下按键**能够解除这个阻塞函数，先鼠标选好点，在键盘按一下空格，就可以录入点了

迭代过程中卡死的情况，通过调整标定板姿势解决，尽量保证能够找到两个矩形出来

迭代成功之后最好把终端的输出保存一下，这个包的输出没太看懂
  
# 外参标定效果
  
按照标定输出的tf变换，雷达和图像**互相垂直**。

猜测是一开始的文件里面指定的旋转参数有问题，得看看源码是怎么转的。

目前已经知道雷达的坐标系是(从电源线向前看)x向前，y向左，z向上。

图片(像素平面)是x向右，y向下，z向前

先把图像转一个角度到img_link，并把标定结果作用在这个坐标系上面
```bash
#camera_link -> img_link,按照xyzypr的顺序
rosrun tf static_transform_publisher 0 0 0 -1.57963 0 -1.5707963 camera_link img_link 100
#img_link -> velodyne,这里稍微调整了一点点移动量
rosrun tf static_transform_publisher -0.172712 0.0906901 0.0299106 2.70027 -1.79366 -1.07103 img_link velodyne 100
```
打开rviz，打开点云显示，再打开camera(不是image)，就可以看到标定效果了